<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>day 13 | My iOS book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.0.3">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    <link rel="next" href="../day_14/README.html" />
    
    
    <link rel="prev" href="../day_12/README.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../gitbook/style.css">


        
    <div class="book"  data-level="13" data-basepath=".." data-revision="1473742693053">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                        <i class="fa fa-check"></i>
                        
                         Introduction
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="day_01/README.html">
            
                
                    <a href="../day_01/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         day 01
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2" data-path="day_02/README.html">
            
                
                    <a href="../day_02/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         day 02
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3" data-path="day_03/README.html">
            
                
                    <a href="../day_03/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         day 03
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4" data-path="day_04/README.html">
            
                
                    <a href="../day_04/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                         day 04
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="5" data-path="day_05/README.html">
            
                
                    <a href="../day_05/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                         day 05
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="6" data-path="day_06/README.html">
            
                
                    <a href="../day_06/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>6.</b>
                        
                         day 06
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="7" data-path="day_07/README.html">
            
                
                    <a href="../day_07/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>7.</b>
                        
                         day 07
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="8" data-path="day_08/README.html">
            
                
                    <a href="../day_08/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>8.</b>
                        
                         day 08
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="9" data-path="day_09/README.html">
            
                
                    <a href="../day_09/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>9.</b>
                        
                         day 09
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="10" data-path="day_10/README.html">
            
                
                    <a href="../day_10/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>10.</b>
                        
                         day 10
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="11" data-path="day_11/README.html">
            
                
                    <a href="../day_11/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>11.</b>
                        
                         day 11
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="12" data-path="day_12/README.html">
            
                
                    <a href="../day_12/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>12.</b>
                        
                         day 12
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="13" data-path="day_13/README.html">
            
                
                    <a href="../day_13/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>13.</b>
                        
                         day 13
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="14" data-path="day_14/README.html">
            
                
                    <a href="../day_14/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>14.</b>
                        
                         day 14 
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../" >My iOS book</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_44103">
                    
                        <h1 id="day-13">day 13</h1>
<h2 id="quartz2d">Quartz2D</h2>
<ul>
<li>简介</li>
<li>基本线条绘制</li>
<li>小实例</li>
<li>应用</li>
</ul>
<hr>
<h4 id="">简介</h4>
<ul>
<li>Quartz2D <ul>
<li>一个同时支持Mac和iOS的二维绘图引擎</li>
<li>画基本线条、绘制文字、图片、截图、自定义<code>UIView</code></li>
<li>当所需控件样式及其复杂时，可以将控件内部的结构绘制出来，就是自定义控件</li>
</ul>
</li>
<li>图形上下文<ul>
<li>用来保存用户绘制的内容状态，并决定绘制到哪里</li>
<li>用户会把需要绘制的内容保存到图像上下文，根据选择的图形上下文，显示到不同的地方，即输出的目标不同</li>
<li>常见上下文<pre><code> Bitmap Graphics Context    位图上下文
 PDF Graphics Context       PDF上下文
 Window Graphics Context    窗口上下文
 Layer Graphics Context     图层上下文
 Printer Graphics Context   打印上下文
</code></pre></li>
</ul>
</li>
<li>自定义<code>UIView</code><ol>
<li>创建一个继承<code>UIView</code>的<code>SLView</code></li>
<li>实现<code>DrawRect</code>方法</li>
<li>在<code>DrawRect</code>方法中取得与View相关的上下文</li>
<li>绘制路径</li>
<li>把描述好的路径保存到上下文中</li>
<li>把上下文中的内容渲染到View上</li>
</ol>
</li>
</ul>
<hr>
<h4 id="">基本线条绘制</h4>
<ul>
<li><code>DrawRect</code>方法<ul>
<li>在这给方法中完成绘图操作，只有这个方法才能拿到与View关联的上下文</li>
<li>当View显示时，系统自动调用</li>
</ul>
</li>
<li>画直线<ul>
<li>基本过程 <pre><code class="lang-objc"><span class="hljs-comment">// 获取与view关联的上下文</span>
CGContextRef ctx = UIGraphicsGetCurrentContext();
<span class="hljs-comment">// 绘制路径</span>
UIBezierPath *path = [UIBeizerPath beizerPath];
<span class="hljs-comment">// 设置起点</span>
[path moveToPoint:CGPointMake(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>)];
<span class="hljs-comment">// 添加一根线到一个点</span>
[path addLineToPoint:CGPointMake(<span class="hljs-number">200</span>, <span class="hljs-number">100</span>)];
<span class="hljs-comment">// 把路径添加到上下文</span>
CGContextAddPath(ctx, path<span class="hljs-variable">.CGPath</span>);
<span class="hljs-comment">// 在view上渲染</span>
CGContextStrokePath(ctx);
</code></pre>
</li>
<li>再添加一条线<ul>
<li>第一种：重新设置起点，添加一根线到一个点，一个<code>UIBezierPath</code>路径可以有多条线
第二种：直接在原来的基础上，把上一条线的终点作为起点，直接<code>addLineToPoint:</code></li>
</ul>
</li>
<li>线的属性<br/>
设置这属性，就是修改图形上下文的状态<pre><code> 设置线宽：CGContextSetLineWidth(ctx, 20);
 设置线段的连接样式：CGContextSetLineJoin(ctx, kCGLineJoinRound);
 添加顶角样式：CGContextSetLineCap(ctx, kCGLineCapRound);
 设置线的颜色：[[UIColor redColor] setStroke];
</code></pre></li>
</ul>
</li>
<li>画曲线<ul>
<li>画曲线方法比较特殊需要一个控制点来决定曲线的弯曲程度<pre><code class="lang-objc"><span class="hljs-comment">// 先设置一个曲线的起点</span>
[path moveToPoint:CGPointMake(<span class="hljs-number">30</span>, <span class="hljs-number">125</span>)];
<span class="hljs-comment">// 再添加到个点到曲线的终点，同时还须要一个controlPoint(控制点决定曲线弯曲)</span>
[path addQuadCurveToPoint:CGPointMake(<span class="hljs-number">200</span>, <span class="hljs-number">120</span>) controlPoint:CGPointMake(<span class="hljs-number">120</span>, <span class="hljs-number">40</span>)];
</code></pre>
</li>
</ul>
</li>
<li>画矩形（圆角）<ul>
<li>画矩形直接利用UIBezierPath给我们封装好的路径方法<pre><code class="lang-objc"><span class="hljs-comment">// (x, y)点决定了矩形左上角的点在哪个位置</span>
<span class="hljs-comment">// (width, height)是矩形的宽度高度</span>
bezierPathWithOvalInRect:CGRectMake(x, y, width, height)
</code></pre>
</li>
<li>圆角矩形的画法多了一个参数<code>cornerRadius</code><pre><code class="lang-objc"><span class="hljs-comment">// cornerRadius它是矩形的圆角半径.</span>
<span class="hljs-comment">// 通过圆角矩形可以画一个圆，当矩形是正方形的时候，把圆角半径设为宽度的一半，就是一个圆</span>
bezierPathWithRoundedRect:CGRectMake(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>) cornerRadius:<span class="hljs-number">10</span>
</code></pre>
</li>
</ul>
</li>
<li>画椭圆（圆）<ul>
<li>方法<pre><code class="lang-objc"><span class="hljs-comment">// 前两个参数分别代码圆的圆心，后面两个参数分别代表圆的宽度与高度</span>
<span class="hljs-comment">// 宽高都相等时，画的是一个正圆，不相等时画的是一个椭圆</span>
bezierPathWithOvalInRect:CGRectMake(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>)
</code></pre>
</li>
</ul>
</li>
<li>画圆弧<ul>
<li>首先要确定圆才能确定圆弧，圆孤就是圆的一部分<pre><code class="lang-objc"><span class="hljs-comment">// center：圆心</span>
<span class="hljs-comment">// radius：圆的半径</span>
<span class="hljs-comment">// startAngle：起始角度</span>
<span class="hljs-comment">// endAngle：终点角度</span>
<span class="hljs-comment">// clockwise：Yes顺时针，No逆时针    </span>
<span class="hljs-comment">// 注意：startAngle角度的位置是从圆的最右侧为0度</span>
UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(<span class="hljs-number">125</span>, <span class="hljs-number">125</span>) radius:<span class="hljs-number">100</span> startAngle:<span class="hljs-number">0</span> endAngle:M_PI * <span class="hljs-number">2</span> clockwise:<span class="hljs-literal">YES</span>];
</code></pre>
</li>
<li>UIKit的封装<ul>
<li><code>[path stroke]</code>直接使用</li>
<li>底层：获取上下文，拼接路径，添加路径，渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="">小实例</h4>
<ul>
<li><p>下载进度条</p>
<ul>
<li>搭建界面</li>
<li>拖动滑块时，圆弧的大小也改变，进度数字也实时变（显示%需要转义%%）</li>
<li><p>相关代码</p>
<pre><code class="lang-objc"><span class="hljs-comment">// 从最上面，按顺时针画，它的起始角度是-90度，结束角度也是-90度</span>
<span class="hljs-comment">// 起始角度-90度，看你下载进度是多少，假如说你下载进度是100，就是1 * 360度</span>
CGContextRef ctx = UIGraphicsGetCurrentContext();
<span class="hljs-built_in">CGPoint</span> center = CGPointMake(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
<span class="hljs-built_in">CGFloat</span> radius = rect<span class="hljs-variable">.size</span><span class="hljs-variable">.width</span> * <span class="hljs-number">0.5</span>;
<span class="hljs-built_in">CGFloat</span> startA = -M_PI_2;
<span class="hljs-built_in">CGFloat</span> endA = -M_PI_2 + M_PI * <span class="hljs-number">2</span> * progress;
UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="hljs-literal">YES</span>];

要获得Progress的值，拖线拿到它的该变量
要在值改变的时候就要传进来，并且每次值改变的时候就要去绘制圆弧
重写`setProgress:`方法
- (<span class="hljs-keyword">void</span>)setProgress:(<span class="hljs-built_in">CGFloat</span>)progress{
    _progress = progress;
    <span class="hljs-comment">// 手动调用drawRect方法，让它重新绘制</span>
    [<span class="hljs-keyword">self</span> drawRect:<span class="hljs-keyword">self</span><span class="hljs-variable">.bounds</span>];
}
</code></pre>
</li>
<li>运行后不绘制<ul>
<li>原因：drawRect方法是不能手动调用，因为在drawRect方法中需要获取跟View相关联的上下文。系统在调用drawRect方法时，会自动创建一个跟View相关联的上下文，并且传递给它。自己调用，没有给drawRect方法传递上下文，所以在draw方法中没有上下文</li>
<li>解决：想要重绘，调用<code>[self setNeedsDisplay]</code>，告诉系统重新绘制View，系统就会自动调用drawRect方法，这样就可以获得上下文进行绘制</li>
</ul>
</li>
</ul>
</li>
<li><p>饼状图</p>
<ul>
<li>方法<pre><code class="lang-objc"><span class="hljs-comment">// 获取上下文</span>
CGContextRef ctx =  UIGraphicsGetCurrentContext();
<span class="hljs-comment">// 基本数据</span>
<span class="hljs-built_in">CGPoint</span> center = CGPointMake(<span class="hljs-number">125</span>, <span class="hljs-number">125</span>);
<span class="hljs-built_in">CGFloat</span> radius = <span class="hljs-number">100</span>;
<span class="hljs-built_in">CGFloat</span> startA = <span class="hljs-number">0</span>;
<span class="hljs-built_in">CGFloat</span> endA = <span class="hljs-number">0</span>;
<span class="hljs-built_in">CGFloat</span> angle = <span class="hljs-number">25</span> / <span class="hljs-number">100.0</span> * M_PI * <span class="hljs-number">2</span>;
endA = startA + angle;
<span class="hljs-comment">// 拼接路经</span>
UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="hljs-literal">YES</span>];
<span class="hljs-comment">// 添加一条线到圆心</span>
[path addLineToPoint:center];
<span class="hljs-comment">// 把路径添加到上下文</span>
CGContextAddPath(ctx, path<span class="hljs-variable">.CGPath</span>);
<span class="hljs-comment">// 把上下文渲染到View</span>
CGContextFillPath(ctx);
<span class="hljs-comment">// 第二个扇形</span>
startA = endA;
angle = <span class="hljs-number">25</span> / <span class="hljs-number">100.0</span> * M_PI * <span class="hljs-number">2</span>;
endA = startA + angle;
path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="hljs-literal">YES</span>];
[path addLineToPoint:center];
<span class="hljs-comment">// 把二个路径添加到上下文</span>
CGContextAddPath(ctx, path<span class="hljs-variable">.CGPath</span>);
<span class="hljs-comment">// 把上下文渲染到View</span>
CGContextFillPath(ctx);
<span class="hljs-comment">// 添加第二个扇形之后，发现它们的颜色都一样，想要修改它的颜色，在下面再写一个</span>
[[<span class="hljs-built_in">UIColor</span> greenColor] set];
</code></pre>
</li>
<li>第三个扇形的基本方法与上面基本相同，发现代码重复较多，进行抽取</li>
<li><p>抽取</p>
<pre><code class="lang-objc"><span class="hljs-comment">// 假设给一组数据</span>
<span class="hljs-built_in">NSArray</span> datas = @[@<span class="hljs-number">25</span>, @<span class="hljs-number">25</span>, @<span class="hljs-number">50</span>];
<span class="hljs-built_in">CGPoint</span> center = CGPointMake(<span class="hljs-number">125</span>, <span class="hljs-number">125</span>);
<span class="hljs-built_in">CGFloat</span> radius = <span class="hljs-number">100</span>;
<span class="hljs-built_in">CGFloat</span> startA = <span class="hljs-number">0</span>;
<span class="hljs-built_in">CGFloat</span> angle = <span class="hljs-number">0</span>;
<span class="hljs-built_in">CGFloat</span> endA = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSNumber</span> *number <span class="hljs-keyword">in</span> datas) {
     startA = endA;
     angle = number<span class="hljs-variable">.intValue</span> / <span class="hljs-number">100.0</span> * M_PI * <span class="hljs-number">2</span>;
     endA = startA + angle;
     <span class="hljs-comment">// 描述路径</span>
     UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="hljs-literal">YES</span>];
     <span class="hljs-comment">// 添加直线</span>
     [path addLineToPoint:center];
     <span class="hljs-comment">// 随机颜色</span>
     [[<span class="hljs-keyword">self</span> randomColor] set];
     <span class="hljs-comment">// 闭合</span>
     [path fill];
}
<span class="hljs-comment">// 随机返回颜色，开发时可定义为宏</span>
- (<span class="hljs-built_in">UIColor</span> *)randomColor {
     <span class="hljs-built_in">CGFloat</span> r = arc4random_uniform(<span class="hljs-number">256</span>)/ <span class="hljs-number">255.0</span>;
     <span class="hljs-built_in">CGFloat</span> g = arc4random_uniform(<span class="hljs-number">256</span>)/ <span class="hljs-number">255.0</span>;
     <span class="hljs-built_in">CGFloat</span> b = arc4random_uniform(<span class="hljs-number">256</span>)/ <span class="hljs-number">255.0</span>;
     <span class="hljs-keyword">return</span> [<span class="hljs-built_in">UIColor</span> colorWithRed:r green:g blue:b alpha:<span class="hljs-number">1</span>];
}
</code></pre>
</li>
</ul>
</li>
<li>UIKit绘图<ul>
<li>绘制文字<pre><code class="lang-objc"><span class="hljs-comment">// 先创建好要画的文字</span>
<span class="hljs-built_in">NSString</span> *str = <span class="hljs-string">@"Sleen"</span>;
<span class="hljs-comment">// drawAtPoint：要画到哪个位置</span>
<span class="hljs-comment">// withAttributes：文本的样式.</span>
[str drawAtPoint:CGPointZero withAttributes:<span class="hljs-literal">nil</span>];
</code></pre>
</li>
<li>属性设置<pre><code class="lang-objc"><span class="hljs-comment">// 通过绘制方法的最后一个属性withAttributes来设置文字属性</span>
<span class="hljs-comment">// 创建一个可变的字典,设置key,value</span>
<span class="hljs-built_in">NSMutableDictionary</span> *dict = [NSMueDictionary dictionary];
<span class="hljs-comment">// 字体</span>
dict[NSFontAttributeName] = [<span class="hljs-built_in">UIFont</span> sys   tOfSize:<span class="hljs-number">50</span>];
<span class="hljs-comment">// 颜色</span>
dict[NSForegroundColorAttributeName] = [<span class="hljs-built_in">UIColor</span> red   ;
<span class="hljs-comment">// 设置边框颜色</span>
dict[NSStrokeColorAttributeName] = [<span class="hljs-built_in">UIColor</span> redCo;
dict[NSStrokeWidthAttributeName] = @<span class="hljs-number">1</span>;
<span class="hljs-comment">// 阴影</span>
NSShadow *shadow = [[NSShadow alloc] init];
shadow<span class="hljs-variable">.shadowOffset</span> = CGSizeMake(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);
shadow<span class="hljs-variable">.shadowColor</span> = [<span class="hljs-built_in">UIColor</span> greenColor];
shadow<span class="hljs-variable">.shadowBlurRadius</span> = <span class="hljs-number">3</span>;
dict[NSShadowAttributeName] = shadow;
</code></pre>
</li>
<li>绘制图片<ul>
<li>绘制图片同样开始要先把图片素材导入</li>
<li>AtPoint：参数说明图片要绘制到哪个位置</li>
<li>通过调用UIKit的方法<code>drawAtPoint:CGPointZero</code>方法进行绘制</li>
</ul>
</li>
<li>两个方法<ul>
<li>文字 <ol>
<li><code>drawAtPoint:</code> 不能换行</li>
<li><code>drawInRect:</code> 能够换行</li>
</ol>
</li>
<li>图片<ol>
<li><code>drawAtPoint:</code> 按照图片尺寸绘制</li>
<li><code>drawInRect:</code> 图片尺寸与Rect的尺寸一样</li>
</ol>
</li>
</ul>
</li>
<li>平铺图片<pre><code class="lang-objc">[image drawAsPatternInRect:rect];
</code></pre>
</li>
<li>快速矩形<pre><code class="lang-objc">UIRectFill(rect);
</code></pre>
</li>
<li>裁剪<pre><code class="lang-objc"><span class="hljs-comment">// 这个方法必须要设置好裁剪区域，才能有裁剪效果</span>
UIRectClip(CGRectMake(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>));
</code></pre>
</li>
</ul>
</li>
<li>仿UIImageView<ul>
<li>思路<ul>
<li>分析系统UIImageView的功能<ol>
<li>创建UIImageView对象，设置frame，设置image，添加到view上</li>
<li>创建时就设置image，frame与图片尺寸相同</li>
</ol>
</li>
</ul>
</li>
<li>实现<ol>
<li>新建一个UIView，如<code>SLImageView</code></li>
<li>给<code>SLImageView</code>添加一个UIImage属性</li>
<li>在<code>DrawRect</code>方法中绘制图片到view上</li>
<li>重写UIImage的set方法，实现切换图片</li>
<li>提供<code>- (instancetype)initWithImage:(UIImage *)image;</code>方法</li>
</ol>
</li>
<li>代码<pre><code class="lang-objc">- (instancetype)initWithImage:(<span class="hljs-built_in">UIImage</span> *)image {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) {
         <span class="hljs-keyword">self</span><span class="hljs-variable">.frame</span> = CGRectMake(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, image<span class="hljs-variable">.size</span><span class="hljs-variable">.width</span>, image<span class="hljs-variable">.size</span><span class="hljs-variable">.height</span>);
         _image = image;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}
- (<span class="hljs-keyword">void</span>)setImage:(<span class="hljs-built_in">UIImage</span> *)image {
    _image = image;
    [<span class="hljs-keyword">self</span> setNeedsDisplay];
}
- (<span class="hljs-keyword">void</span>)drawRect:(<span class="hljs-built_in">CGRect</span>)rect {
    [_image drawInRect:rect];
}
</code></pre>
</li>
</ul>
</li>
<li><p>雪花</p>
<ul>
<li>思路<ol>
<li>首先绘制一个雪花</li>
<li>在View加载完毕添加一个定时器</li>
<li>在定时器中调用重绘方法</li>
<li>在重绘方法中不断修改雪花的y值</li>
<li>当y值超过屏幕，就重设为0</li>
</ol>
</li>
<li>定时器<ol>
<li>NSTime和CADisplayLink</li>
<li><code>setNeedsDisplay</code>方法底层会调用<code>DrawRect</code>，但是它不是立马就进行重绘，它仅仅是设置了一个重绘标志，等到下一次屏幕刷新的时候才会调用<code>DrawRect</code>方法</li>
<li>NSTime的时间可能和屏幕的刷新时间不匹配，就会产生延迟，造成界面卡顿，CADisplayLink的时间正好与屏幕刷新时间相同</li>
<li>使用CADisplayLink添加定时器<pre><code class="lang-objc"><span class="hljs-comment">// target：哪个对象要监听方法</span>
<span class="hljs-comment">// selector：监听的方法名称</span>
CADisplayLink *link = [CADisplayLink displayLinkWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(setNeedsDisplay)];
<span class="hljs-comment">// 想要让CADisplayLink工作，必须得要把它添加到主运行循环</span>
<span class="hljs-comment">// 只要添加到主运行循环，跟模式没有关系</span>
[link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
</code></pre>
</li>
</ol>
</li>
<li><p>代码</p>
<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)awakeFromNib {
    CADisplayLink *link = [CADisplayLink displayLinkWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(setNeedsDisplay)];
    [link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
}
- (<span class="hljs-keyword">void</span>)drawRect:(<span class="hljs-built_in">CGRect</span>)rect {
    <span class="hljs-keyword">if</span> (_snowY &gt; rect<span class="hljs-variable">.size</span><span class="hljs-variable">.height</span>) {
         _snowY = <span class="hljs-number">0</span>;
    }
    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@"雪花"</span>];
    [image drawAtPoint:CGPointMake(<span class="hljs-number">0</span>, _snowY)];
    _snowY += <span class="hljs-number">10</span>;
}
</code></pre>
</li>
</ul>
</li>
<li>水印<ul>
<li>用处<ul>
<li>标明图片来源（微博）</li>
<li>防止盗图（淘宝）</li>
</ul>
</li>
<li>思路<ol>
<li>开启一个和原始图片一样的图片上下文</li>
<li>把原始图片绘制到上下文</li>
<li>再把要添加的水印（文字，logo）等绘制到图片上下文</li>
<li>最后从上下文中取出一张图片</li>
<li>关闭上下文</li>
</ol>
</li>
<li>主要代码<pre><code class="lang-objc"><span class="hljs-comment">// 开启一个图片上下文?</span>
<span class="hljs-comment">// size：开启多大的上文</span>
<span class="hljs-comment">// opaque：不透明度</span>
<span class="hljs-comment">// scale：缩放上下文.</span>
UIGraphicsBeginImageContextWithOptions(image<span class="hljs-variable">.size</span>, <span class="hljs-literal">YES</span>, <span class="hljs-number">0</span>);
<span class="hljs-comment">// 从图片上下文当中生成一张图片</span>
<span class="hljs-built_in">UIImage</span> *newImage = UIGraphicsGetImageFromCurrentImageContext();
<span class="hljs-comment">// 关闭上下文</span>
UIGraphicsEndImageContext();
</code></pre>
</li>
</ul>
</li>
<li>圆形头像（裁剪）<ul>
<li>思路<ol>
<li>开启一个图片上下文</li>
<li>上下文的大小和原始图片保持一样，以免图片被拉伸缩放</li>
<li>在上下文的上面添加一个圆形裁剪区域，圆形裁剪区域的半径大小和图片的宽度一样大</li>
<li>把要裁剪的图片绘制到图片上下文当中</li>
<li>从上下文当中取出图片</li>
<li>关闭上下文</li>
</ol>
</li>
<li>主要代码<pre><code class="lang-objc"><span class="hljs-comment">// 设置圆形路径</span>
UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, image<span class="hljs-variable">.size</span><span class="hljs-variable">.width</span>, image<span class="hljs-variable">.size</span><span class="hljs-variable">.width</span>)];
<span class="hljs-comment">// 把一个路径设为裁剪区域</span>
[path addClip];
</code></pre>
</li>
</ul>
</li>
<li>截屏<ul>
<li>思路<ul>
<li>将UIView上的东西保存到图片上下文中，生成一张新图片</li>
<li>UIView神的东西是不能直接保存的，需要的是view内部的layer层</li>
<li>调用layer的<code>renderInContext:</code>方法</li>
</ul>
</li>
<li>代码<pre><code class="lang-objc"><span class="hljs-comment">// 开启一个图片上</span>
UIGraphicsBeginImageContextWithOptions(<span class="hljs-keyword">self</span><span class="hljs-variable">.view</span><span class="hljs-variable">.bounds</span><span class="hljs-variable">.size</span>, <span class="hljs-literal">NO</span>, <span class="hljs-number">0</span>);
<span class="hljs-comment">// 获取当前的上下文</span>
CGContextRef ctx = UIGraphicsGetCurrentContext();
<span class="hljs-comment">// 把控制器View的内容绘制上下文当中</span>
[<span class="hljs-keyword">self</span><span class="hljs-variable">.view</span><span class="hljs-variable">.layer</span> renderInContext:ctx];
<span class="hljs-comment">// 从上下文当中取出图片</span>
<span class="hljs-built_in">UIImage</span> *newImage = UIGraptImageFromCurrentImageContext();
<span class="hljs-comment">// 关闭上下文</span>
UIGraphicsEndImageContext();
</code></pre>
</li>
</ul>
</li>
<li>图片擦除<ul>
<li>思路<ol>
<li>两张不同的图片，上面一张，下面一张</li>
<li>添加手势，手指移动擦除图片</li>
<li>确定擦除区域大小和位置</li>
<li>生成新的图片（擦除区域透明），就可以看到后面的图片</li>
</ol>
</li>
<li>代码<pre><code class="lang-objc"><span class="hljs-comment">// 确定擦除的范围</span>
<span class="hljs-built_in">CGFloat</span> rectWH = <span class="hljs-number">30</span>;
<span class="hljs-comment">// 获取手指的当前点.curP</span>
<span class="hljs-built_in">CGPoint</span> curP = [pan locationInView:pan<span class="hljs-variable">.view</span>];
<span class="hljs-built_in">CGFloat</span> x = curP<span class="hljs-variable">.x</span> - rectWH * <span class="hljs-number">0.5</span>;
<span class="hljs-built_in">CGFloat</span> y = curP<span class="hljs-variable">.y</span> - rectWH * <span class="hljs-number">0.5</span>;
<span class="hljs-built_in">CGRect</span> rect = CGRectMake(x, y,rectWH, rectWH);
<span class="hljs-comment">// 先把图片绘制到上下文.</span>
UIGraphicsBeginImageContextWithOptions(<span class="hljs-keyword">self</span><span class="hljs-variable">.imageView</span><span class="hljs-variable">.bounds</span><span class="hljs-variable">.size</span>, <span class="hljs-literal">NO</span>, <span class="hljs-number">0</span>);
<span class="hljs-comment">// 获取当前的上下文</span>
CGContextRef ctx = UIGraphicsGetCurrentContext();
<span class="hljs-comment">// 把上面一张图片绘制到上下文.</span>
[<span class="hljs-keyword">self</span><span class="hljs-variable">.imageView</span><span class="hljs-variable">.layer</span> renderInContext:ctx];
<span class="hljs-comment">// 再绘上下文当中图片进行擦除.</span>
CGContextClearRect(ctx, rect);
<span class="hljs-comment">// 生成一张新图片</span>
<span class="hljs-built_in">UIImage</span> *newImage = UIGraphicsGetImageFromCurrentImageContext();
<span class="hljs-comment">// 再把新的图片给重新负值</span>
<span class="hljs-keyword">self</span><span class="hljs-variable">.imageView</span><span class="hljs-variable">.image</span> = newImage;
<span class="hljs-comment">// 关闭上下文.</span>
UIGraphicsEndImageContext();
</code></pre>
</li>
</ul>
</li>
<li>图片截屏<ul>
<li>思路<ol>
<li>手指在屏幕上移动的时候，添加一个半透明的view</li>
<li>开启一个上下文把UIView的farme设置为裁剪区域</li>
<li>把view的layer显示的内容绘制到上下文当中</li>
<li>生成一张新的图片在赋值给UIImageView</li>
</ol>
</li>
<li>具体实现<ol>
<li>给图片添加一个手势，监听手指在图片上的拖动（注意UIImageView默认不能接收事件）</li>
<li>监听手指移动，手指移动时添加一个UIView，x,y就是起始点，手指开始的点，width是x轴的偏移量，height是y轴偏移量</li>
<li>计算代码<pre><code class="lang-objc"><span class="hljs-built_in">CGFloat</span> offSetX = curP<span class="hljs-variable">.x</span> - <span class="hljs-keyword">self</span><span class="hljs-variable">.beginP</span><span class="hljs-variable">.x</span>;
<span class="hljs-built_in">CGFloat</span> offsetY = curP<span class="hljs-variable">.y</span> - <span class="hljs-keyword">self</span><span class="hljs-variable">.beginP</span><span class="hljs-variable">.y</span>;
<span class="hljs-built_in">CGRect</span> rect = CGRectMake(<span class="hljs-keyword">self</span><span class="hljs-variable">.beginP</span><span class="hljs-variable">.x</span>, <span class="hljs-keyword">self</span><span class="hljs-variable">.beginP</span><span class="hljs-variable">.y</span>, offSetX, offsetY);
</code></pre>
</li>
<li>UIView只需要添加一次，给UIView设置成懒加载，保证只有一个UIView，在移动时修改frame就好</li>
<li>开启一个图片上下文，图片上下文的大小为位原始图片尺寸，是整个图片可以截取<pre><code class="lang-objc"><span class="hljs-comment">// 利用UIBezierPath设置一个矩形的裁剪区域</span>
<span class="hljs-comment">// 然后把这个路径设置为裁剪区域</span>
<span class="hljs-comment">// 把路径设为裁剪区域的方法为</span>
[path addClip];
</code></pre>
</li>
<li>把图片绘制到上下文中<pre><code class="lang-objc"><span class="hljs-comment">// 由于是一个UIImageView上面的图片，所以也得需要渲染到上下文当中</span>
<span class="hljs-comment">// 要先获取当前的上下文</span>
<span class="hljs-comment">// 把UIImageView的layer渲染到当前的上下文当中</span>
CGContextRef ctx = UIGraphicsGetCurrentContext();
[<span class="hljs-keyword">self</span><span class="hljs-variable">.imageV</span><span class="hljs-variable">.layer</span> renderInContext:ctx];
</code></pre>
</li>
<li>取出新的图片，重新赋值图片<pre><code class="lang-objc"><span class="hljs-built_in">UIImage</span> *newImage = UIGraphicsGetImageFromCurrentImageContext();
<span class="hljs-keyword">self</span><span class="hljs-variable">.imageV</span><span class="hljs-variable">.image</span> = newImage;
</code></pre>
</li>
<li>关闭上下文,移除上面半透明的UIView<pre><code class="lang-objc">UIGraphicsEndImageContext();
[<span class="hljs-keyword">self</span><span class="hljs-variable">.coverView</span> removeFromSuperview];
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
<li><p>手势解锁 </p>
<ul>
<li>分析界面<ul>
<li>当手指在上面移动时，移动到按钮的一定范围中，会把按钮变成选中状态</li>
<li>并把第一个选中的按钮中心作为一条线的起点，手指移到下一个按钮就会添加一条线</li>
<li>手指松开后就会取消选中，清空所有线</li>
</ul>
</li>
<li>思路<ol>
<li>先判断当前手指在不在当前按钮上，如果在按钮上，就把按钮设置成选中状态</li>
<li>把当前选中的按钮添加到一个数组当中，如果当前按钮已经是选中状态，就不需要再添加到数组中了</li>
<li>每次移动都让它重绘，在绘图中，遍历所有选中按钮</li>
<li>判断数组当中的第一个无素，如果是第一个，那么就把它设为路径的起点，其它都在添加一根线到按钮的圆心</li>
<li>如果当前点不在按钮上，那么就记录住当前手指所在的点，直接从起点添加一根线到当前手指所在的点</li>
</ol>
</li>
<li><p>具体实现</p>
<ol>
<li>搭建界面<pre><code>界面是一个九宫格的布局.九宫格实现思路.
先确定有多少列  cloum = 3;
计算出每列之间的距离
计算为: CGFloat margin = (当前View的宽度 - 列数 * 按钮的宽度) / 总列数 + 1
每一列的X的值与它当前所在的行有关
当前所在的列为:curColum = i % cloum
每一行的Y的值与它当前所在的行有关.
当前所在的行为:curRow = i / cloum
每一个按钮的X值为, margin + 当前所在的列 * (按钮的宽度 + 每个按钮之间的间距)
每一个按钮的Y值为 当前所在的行 * (按钮的宽度 + 每个按钮之间的距离)
</code></pre>具体代码<pre><code class="lang-objc"><span class="hljs-comment">// 总列数</span>
<span class="hljs-keyword">int</span> colum = <span class="hljs-number">3</span>;
<span class="hljs-comment">// 每个按钮的宽高</span>
<span class="hljs-built_in">CGFloat</span> btnWH = <span class="hljs-number">74</span>;
<span class="hljs-comment">// 每个按钮之间的距离</span>
<span class="hljs-built_in">CGFloat</span> margin = (<span class="hljs-keyword">self</span><span class="hljs-variable">.bounds</span><span class="hljs-variable">.size</span><span class="hljs-variable">.width</span> - colum * btnWH)  (colum + <span class="hljs-number">1</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">self</span><span class="hljs-variable">.subviews</span><span class="hljs-variable">.count</span>; i++ ){
     <span class="hljs-comment">// 当前所在的列</span>
     <span class="hljs-keyword">int</span> curColum = i % colum;
     <span class="hljs-comment">// 当前所在的行</span>
     <span class="hljs-keyword">int</span> curRow = i / colum;
     <span class="hljs-built_in">CGFloat</span> x = margin + (btnWH + margin) * curColum;
     <span class="hljs-built_in">CGFloat</span> y = (btnWH + margin) * curRow;
     <span class="hljs-comment">// 取出所有的子控件</span>
     <span class="hljs-built_in">UIButton</span> *btn = <span class="hljs-keyword">self</span><span class="hljs-variable">.subviews</span>[i];
     btn<span class="hljs-variable">.frame</span> = CGRectMake(x, y, btnWH, btnWH);
}
</code></pre>
</li>
<li><p>监听手指在上面的操作</p>
<pre><code>在手指点击屏幕时，如果当前手指所在的点在按钮上，那就让按钮变成选中状态
判断一个点在不在一个区域，在返回YES，不在NO
CGRectContainsPoint(btn.frame, point)

当手指点击屏幕的时候，需要做的事情：
(1) 获取当前手指所在的点
  UITouch *touch = [touches anyObject];
  GPoint curP =  [touch locationInView:self];
(2) 判断当前点在不在按钮上
  for (UIButton *btn in self.subviews) {
      if (CGRectContainsPoint(btn.frame, point)) {
          return btn;
      }
  }
(3) 如果当前点在按钮上，并且当前按钮不是选中的状态
  那么把当前的按钮成为选中状态
  并且把当前的按钮添加到数组当中
</code></pre></li>
<li>在绘图方法中<pre><code>创建路径 
遍历出有的选中按钮，如果是第一个按钮，把第一个按钮的中心点当做是路径的起点
其它按钮都直接添加一条线，到该按钮的中心
遍历完所有的选中按钮后
最后添加一条线到当前手指所在的点
</code></pre></li>
</ol>
</li>
</ul>
</li>
<li>画板<ul>
<li>分析<pre><code> 顶部是一个工具栏。有清屏、撤销、橡皮擦、照片功能，最右部是一个保存按钮
 中间部分为画板区域
 最下部拖动滑块能够改变画笔的粗线，可以选颜色 
</code></pre></li>
<li>界面搭建<pre><code> 最上部为一个ToolBar，往ToolBar拖些item，使用ToolBar的好处，里面按钮的位置不需要我们再去管理
 给最上部的工具栏做自动布局，离父控件左、上、右都为0，保存工具条的高度不变
 拖一个UIView当前下部的View，在下部的View当中拖累三个按钮，设置每一个按钮的背景颜色，点击每一按钮时办到设置画笔的颜色
 其中三个按钮只间的间距始终保存等，每一个按钮的宽度和高度都相等，通过自动布局的方式办到
 先把这个UIView的自动布局设好，让其左、右、下都是0，高度固定
 自动布局设置为：第一个按钮高度固定，与左、右、下都保持20间距
 第二个按钮与第一个按钮，高度、宽度、centerY都相等，与右边有20间距
 第三个按钮也是第一个按钮的高度、宽度、centerY都相等，与右边有20间距，最右边也保持20间距
 最后是中间的画板区域，画板区域只需要距离上、下、左、右都为0即可
</code></pre></li>
<li>画板功能<ol>
<li>监听手指在屏幕上的状态，在开始点击屏幕的时候，创建一个路径，并把手指当前的点设为路径的起点</li>
<li>设置一个成员属性记录当前绘制的路径，并把当前的路径添加到路径数组当中</li>
<li>当手指在移动的时候，用当前的路径添加一根线到当前手指所在的点，然后进行重绘</li>
<li>在绘图方法当中，取出所有的路径，把所有的路径给绘制出来</li>
</ol>
</li>
<li>小工具<ul>
<li>清屏<pre><code>删除所有路径，进行重绘
</code></pre></li>
<li>撤销<pre><code>删除最后一条路径，进行重绘
</code></pre></li>
<li>线宽<pre><code>由于每一条线宽度都不样，所以要在开始创建路径的时，就要添加一个成员属性，设置一个默认值
在把当前路径添加到路径数组之前，设置好线的宽度，然后重写线宽属性方法
下一次再创建路径时，线的宽度就是当前设置的宽度
</code></pre></li>
<li>颜色<pre><code>每一条线的颜色也不一样，也需要一个属性记录每一条路径的颜色
UIBezierPath没有给我们直接提供设置颜色的属性，需要自定义一个UIBezierPath，创建一个MyBezierPath类，继承UIBezierPath，在该类中添加一个颜色的属性
在创建路径的时候，直接使用自己定义的路径，设置路径默认的一个颜色，方法给设置线宽一样
在绘图过程中，取出来的都是MyBezierPath，把MyBezierPath的颜色设置为路径的颜色
</code></pre></li>
<li>橡皮擦功能<pre><code>路径的颜色设为白色
</code></pre></li>
</ul>
</li>
<li>保存功能<ol>
<li>开启一个跟View相同大小的图片上下文</li>
<li>把View的layer上面内容渲染到上下文当中</li>
<li>生成一张图片，把图片保存到上下文<pre><code class="lang-objc"><span class="hljs-comment">// 第一个参数：要写入到相册的图片</span>
<span class="hljs-comment">// 第二个参数：哪个对象坚听写入完成时的状态</span>
<span class="hljs-comment">// 第三个参数：图片保存完成时调用的方法</span>
UIImageWriteToSavedPhotosAlbum(newImage, <span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(image:didFinishSavingWithError: contextInfo:), <span class="hljs-literal">nil</span>);
<span class="hljs-comment">// 注意:图片保存完成时调用的方法必须得是image:didFinishSavingWithError: contextInfo:</span>
</code></pre>
</li>
</ol>
</li>
<li>选择图片<ol>
<li>弹出系统相册<pre><code class="lang-objc"><span class="hljs-comment">// 使用UIImagePickerController控件器Modal出它来.</span>
UIImagePickerController *pick = [[UIImagePickerController alloc] init];
<span class="hljs-comment">// 设置照片的来源</span>
pick<span class="hljs-variable">.sourceType</span> =  UIImagePickerControllerSourceTypeSavedPhotosAlbum;
<span class="hljs-comment">// 设置代码，监听选择图片，UIImagePickerController比较特殊，它需要遵守两个协议&lt;UINavigationControllerDelegate, UIImagePickerControllerDelegate&gt;</span>
pick<span class="hljs-variable">.delegate</span> = <span class="hljs-keyword">self</span>;
<span class="hljs-comment">// modal出控件器</span>
[<span class="hljs-keyword">self</span> presentViewController:pick animated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];
<span class="hljs-comment">// 注意没有实现代码方法时，选择一张照片会自动的dismiss掉相册控制器，但是设置代码后，就得要自己去dismiss了</span>
</code></pre>
</li>
<li>实现代理，取得照片<pre><code class="lang-objc"><span class="hljs-comment">// 选择的照片就在这个方法第二个参数当中, 它是一个字典</span>
- (<span class="hljs-keyword">void</span>)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(nonnull <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *,<span class="hljs-keyword">id</span>&gt; *)info {
    <span class="hljs-comment">// 获取当前选中的图片,通过UIImagePickerControllerOriginalImage就能获取</span>
    <span class="hljs-built_in">UIImage</span> *image = info[UIImagePickerControllerOriginalImage];
}
</code></pre>
</li>
<li>得到照片的布局<pre><code>获取完图片后，图片是能够缩放、平移的，因此获取完图片后，是在画板板View上面添加了一个UIView，只有UIView才能做平移、缩放、旋转等操作
因此做法为，在图片选择完毕后，添加一个和画板View相同大小的UIView，这个UIView内部有一个UIImageView
对这个UIImageView进行一些手势操作，操作完成时，长按图片，把View的内容截屏，生成一张图片，把新生成的图片绘制到画板上面
</code></pre></li>
</ol>
</li>
<li>绘制图片<pre><code>  在画板View当中提供一个UImage属性，供外界传递，重写属性的set方法，每次传递图片时进行重绘
  画图片也有有序的，所以要把图片也添加到路径数组当中
  在绘图片过过程当中，如果发现取出来的是一个图片类型，那就直接图片绘制到上下文当中
</code></pre>具体代码<pre><code class="lang-objc">- (<span class="hljs-keyword">void</span>)drawRect:(<span class="hljs-built_in">CGRect</span>)rect{
     <span class="hljs-keyword">for</span> (DrawPath *path <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span><span class="hljs-variable">.pathArray</span>) {  
          <span class="hljs-keyword">if</span> ([path isKindOfClass:[<span class="hljs-built_in">UIImage</span> class]]) {
               <span class="hljs-built_in">UIImage</span> *image = (<span class="hljs-built_in">UIImage</span> *)path;
               [image drawInRect:rect];
          }<span class="hljs-keyword">else</span> {
               [path<span class="hljs-variable">.lineColor</span> set];
               [path stroke];
          }
     }
}
</code></pre>
</li>
</ul>
</li>
</ul>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../day_12/README.html" class="navigation navigation-prev " aria-label="Previous page: day 12"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../day_14/README.html" class="navigation navigation-next " aria-label="Next page: day 14 "><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
